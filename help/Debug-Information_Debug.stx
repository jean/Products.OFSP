Debug Information - Debugging Information: Online Zope debugging

  Zope provides a simple debugging interface to help
  product authors find memory leaks in their products
  as well as Zope itself.  There is a special
  object available to users with sufficient access
  to use the control panel.  From the Control Panel, 
  click the 'Debugging information' link.

  The following information is displayed:

    * The Zope version

    * The Python version

    * The system platform name

    * The ID number of the Zope process (if available on your platform)

    * The length of time Zope has been running

    * The top refcounts, including a table listing the changes since the last snapshot

    * The open object database connections

  The Zope version, Python version, and system
  platform name are used to
  verify compatibility between Zope, Python,
  and your system.  On platforms
  where the process ID number is available,
  the Zope process can be managed
  using a more forceful means than is available
  through the web.

  The top refcounts list lets you take a look
  at what is being stored by
  Zope in memory.  The scrollable list shows
  how many instances of each
  type of object are currently in memory.

  If there are items in the list with a very
  high refcount, there is a good chance there
  is a memory leak in a product or in Zope.  Memory leaks,
  which cause Zope to take up excessive amounts of RAM,
  are not likely to occur as often in the Python language
  as they do in languages that do not have a garbage
  collector.  But memory leaks
  still occur when a reference to an object is kept
  even after the object is no longer useful.

  The following example illustrates a simple reference
  to an object that is no longer needed::

    helloString = 'Hello, %s!'
    name = ''

    def printHello():
	    print helloString % name

    def printHelloWorld():
	    global name
	    name = 'World'
	    printHello()

    printHelloWorld()

  'printHelloWorld()' sets a variable for the module
  then calls 'printHello()'.
  The problem is that module variables, such as 'name',
  are never cleaned up by the garbage collector.
  The 'name' object, which in this case is just a string but
  could be an image or a DTML method, is kept in memory until
  the Python process exits.  Under normal circumstances,
  the Python process that runs Zope exits only when
  stopped, which could mean months of continuous usage.

  There are many other circumstances where unnecessary
  references can be accidentally held.  Finding the cause
  of a memory leak can be a major task.  Look for books
  and mailing lists on http://www.python.org .

  The table below the list is designed to assist in
  locating a specific memory leak.  The "Update Snapshot"
  link just below the table will take
  the current refcounts and store them in memory.
  Then each time the debugging page is reloaded, the
  table will show the difference in
  refcounts between the snapshot and the current state.

  If your product is causing memory leaks,
  take a snapshot before the memory leak occurs,
  do whatever it is that seems to cause the leak,
  then reload the debugging page.  You should see which
  type of object is is taking up excessive RAM.
  Then check for the leak in the sections of your
  code that deal with that type of object.

  Finally, the debugging page shows a list of currently
  open database connections.  In Zope 2.x a database
  connection usually corresponds
  with an HTTP request.  The left column shows the
  time at which the connection was opened.  If there
  is a request that has been running for a long
  time you may need to restart Zope to kill the
  corresponding thread. The middle column usually
  shows the state of the REQUEST object with size
  of the cache for that connection in parentheses.
  The right column shows
  information about the version the user is working in.





